use std::fs::File;
use std::io::{Write, BufRead, BufReader, Read};
use std::collections::HashMap;
use std::process::Command;
use std::str::FromStr;
use std::thread;
use reqwest::blocking::get;
use regex::Regex;
use crossbeam::channel::unbounded;
use chrono;

// Constants
const URLS: [&str; 4] = [
    "https://cdn.jsdelivr.net/gh/ittuann/GitHub-IP-hosts@main/hosts",
    "https://fastly.jsdelivr.net/gh/ittuann/GitHub-IP-hosts@main/hosts",
    "https://testingcf.jsdelivr.net/gh/ittuann/GitHub-IP-hosts@main/hosts",
    "https://gcore.jsdelivr.net/gh/ittuann/GitHub-IP-hosts@main/hosts",
];

const HOST_FILE_PATH: &str = "c:/windows/system32/drivers/etc/hosts";
const TEMP_FILE_PATH: &str = "temp_hosts.txt";
const TEMP_HOSTS_FILE_PATH: &str = "temp_hosts";
const MAX_PING_TIME: u32 = std::u32::MAX;

// File operations
fn download_hosts_file() -> Result<(), Box<dyn std::error::Error>> {
    for url in URLS.iter() {
        println!("Trying to download from: {}", url);
        match get(*url) {
            Ok(response) => {
                if response.status().is_success() {
                    let content = response.text()?;
                    let mut file = File::create(TEMP_FILE_PATH)?;
                    file.write_all(content.as_bytes())?;
                    println!("Successfully downloaded from: {}", url);
                    return Ok(());
                }
            }
            Err(e) => {
                println!("Failed to download from {}: {}", url, e);
                continue;
            }
        }
    }
    Err("All download attempts failed".into())
}

fn parse_hosts_file() -> Result<HashMap<String, Vec<String>>, Box<dyn std::error::Error>> {
    let file = File::open(TEMP_FILE_PATH)?;
    let reader = BufReader::new(file);
    let mut hosts_map: HashMap<String, Vec<String>> = HashMap::new();

    for line in reader.lines() {
        let line = line?;
        let line = line.trim();
        
        if line.is_empty() || line.starts_with('#') {
            continue;
        }

        let parts: Vec<&str> = line.split_whitespace().collect();
        if parts.len() >= 2 {
            let ip = parts[0].to_string();
            let domain = parts[1].to_string();

            hosts_map.entry(domain)
                .or_insert_with(Vec::new)
                .push(ip);
        }
    }

    Ok(hosts_map)
}

fn write_hosts_file(domain_ips: &HashMap<String, (String, u32)>) -> Result<(), Box<dyn std::error::Error>> {
    let mut file = File::create(TEMP_HOSTS_FILE_PATH)?;
    
    writeln!(file, "# Generated by updatehosts4r")?;
    writeln!(file, "# Date: {}", chrono::Local::now().format("%Y-%m-%d %H:%M:%S"))?;
    writeln!(file)?;
    
    for (domain, (ip, time)) in domain_ips {
        writeln!(file, "{}    {}    # ping: {}ms", ip, domain, time)?;
    }
    
    Ok(())
}

// Network operations
fn ping_ip(ip: &str) -> Result<u32, Box<dyn std::error::Error>> {
    let output = Command::new("ping")
        .args(["-n", "4", "-w", "1000", ip])
        .output()?;

    let output_str = String::from_utf8_lossy(&output.stdout);
    
    if !output.status.success() {
        return Ok(MAX_PING_TIME);
    }

    let mut total_time = 0;
    let mut count = 0;
    let re = Regex::new(r"=(\d+)ms").unwrap();

    for line in output_str.lines() {
        if line.contains(ip) && line.contains("TTL=") {
            if let Some(caps) = re.captures(line) {
                if let Some(time_str) = caps.get(1) {
                    if let Ok(time) = u32::from_str(time_str.as_str()) {
                        total_time += time;
                        count += 1;
                    }
                }
            }
        }
    }

    if count == 0 {
        Ok(MAX_PING_TIME)
    } else {
        Ok(total_time / count)
    }
}

fn select_fastest_ips(hosts_map: &HashMap<String, Vec<String>>) -> HashMap<String, (String, u32)> {
    let mut result = HashMap::new();
    let (tx, rx) = unbounded();
    
    for (domain, ips) in hosts_map {
        let domain = domain.clone();
        let ips = ips.clone();
        let tx = tx.clone();
        
        thread::spawn(move || {
            let mut min_time = MAX_PING_TIME;
            let mut fastest_ip = None;

            for ip in ips {
                match ping_ip(&ip) {
                    Ok(time) => {
                        let time_str = if time == MAX_PING_TIME {
                            "timeout".to_string()
                        } else {
                            format!("{} ms", time)
                        };
                        let domain_str = format!(" {} [{}]", domain, ip);
                        println!("{:<55} ==> {}", domain_str, time_str);
                        if time < min_time {
                            min_time = time;
                            fastest_ip = Some(ip);
                        }
                    },
                    Err(e) => {
                        println!("{} {} ==> {}", domain, ip, e);
                        continue;
                    }
                }
            }

            if let Some(ip) = fastest_ip {
                tx.send((domain, (ip, min_time))).unwrap();
            }
        });
    }

    drop(tx);
    
    while let Ok((domain, ip_time)) = rx.recv() {
        result.insert(domain, ip_time);
    }

    result
}

// System operations
fn copy_and_flush_dns() -> Result<(), Box<dyn std::error::Error>> {
    let mut hosts_content = Vec::new();
    File::open(TEMP_HOSTS_FILE_PATH)?.read_to_end(&mut hosts_content)?;

    let mut system_hosts = File::create(HOST_FILE_PATH)?;
    system_hosts.write_all(&hosts_content)?;

    let output = Command::new("ipconfig")
        .arg("/flushdns")
        .output()?;

    if !output.status.success() {
        return Err("Failed to flush DNS cache".into());
    }

    Ok(())
}

// Main workflow
fn run_select_fastest_ips() -> Result<(), Box<dyn std::error::Error>> {
    let hosts_map = parse_hosts_file()?;
    if hosts_map.is_empty() {
        return Err("Hosts map is empty".into());
    }
    
    println!("Total domains: {}", hosts_map.len());
    
    let fastest_ips = select_fastest_ips(&hosts_map);
    
    println!("\nFastest IPs selected for {} domains", fastest_ips.len());
    println!("\nResults (domain -> ip -> ping time):");
    for (domain, (ip, time)) in &fastest_ips {
        println!("{:>40} -> {:<15} -> {}ms", domain, ip, time);
    }
    
    println!("\nWriting results to hosts file...");
    write_hosts_file(&fastest_ips)?;
    println!("Done!");
    
    Ok(())
}

// Main function
fn main() {
    if let Err(e) = download_hosts_file() {
        println!("Error: {}", e);
        return;
    }

    if let Err(e) = run_select_fastest_ips() {
        println!("Error: {}", e);
        return;
    }

    match copy_and_flush_dns() {
        Ok(_) => println!("\nHosts file updated and DNS cache flushed successfully!"),
        Err(e) => println!("\nWarning: Failed to update system hosts file: {}", e),
    }

    // Clean up temporary files
    if let Err(e) = std::fs::remove_file(TEMP_FILE_PATH) {
        println!("Error deleting temp file: {}", e);
    } else {
        println!("Temp file deleted");
    }
    
    if let Err(e) = std::fs::remove_file(TEMP_HOSTS_FILE_PATH) {
        println!("Error deleting temp hosts file: {}", e);
    } else {
        println!("Temp hosts file deleted");
    }

    // show press any key to exit
    println!("Press any key to exit...");
    let mut input = String::new();
    std::io::stdin().read_line(&mut input).unwrap();
}

// Tests
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_ping_ip_success() {
        let result = ping_ip("39.156.70.46");
        assert!(result.is_ok());
        let avg_time = result.unwrap();
        println!("Acutal Ping time: {}ms {}", avg_time, MAX_PING_TIME);
        assert!(avg_time < MAX_PING_TIME, "Ping time should be less than MAX_PING_TIME");
        assert!(avg_time > 0, "Ping time should be greater than 0");
    }

    #[test]
    fn test_ping_ip_invalid() {
        let result = ping_ip("256.256.256.256");
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), MAX_PING_TIME);
    }

    #[test]
    fn test_ping_ip_unreachable() {
        let result = ping_ip("192.168.255.255");
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), MAX_PING_TIME);
    }

    #[test]
    fn test_select_fastest_ips() {
        assert!(run_select_fastest_ips().is_ok());
    }
}
